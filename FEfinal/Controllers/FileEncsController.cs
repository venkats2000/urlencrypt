
using System.Data.Entity;
using System.Linq;
using System.Net;

using System.Web.Mvc;
using FEfinal.Models;
using System.Security.Cryptography;
using System.IO;
using System.Text;
using System;
using System.Globalization;

namespace FEfinal.Controllers
{
    public class FileEncsController : Controller
    {
        // We need to figure out how to store this securely
        // generated by https://www.random.org/cgi-bin/randbyte?nbytes=32&format=d
        private byte[] SecretKey = { 94, 221 , 79, 237, 212, 119,  83,   3,  97, 146, 113,  87,   1, 163, 176 , 30,243, 76, 91, 250, 94, 112, 85, 131, 47, 10, 39, 150, 163, 52, 127, 154  };
       
        // random vector generated at https://www.random.org/cgi-bin/randbyte?nbytes=16&format=d
        private byte[] InitVector = { 187,  58, 119, 132, 153,  50,  92,  35, 254, 124, 149,  26,   4,  99, 175, 221 };
        

        private ICryptoTransform EncryptorTransform, DecryptorTransform;
        private System.Text.UTF8Encoding UTFEncoder;
        
        public void SetupAES()
        {
            //This is our encryption method
            RijndaelManaged rijm = new RijndaelManaged();

            //Create an encryptor and a decryptor using our encryption method, key, and vector.
            EncryptorTransform = rijm.CreateEncryptor(this.SecretKey, this.InitVector);
            DecryptorTransform = rijm.CreateDecryptor(this.SecretKey, this.InitVector);

            //Used to translate bytes to text and vice versa
            UTFEncoder = new System.Text.UTF8Encoding();
        }

          
        /// Encrypt some text and return a string  
        public string EncryptaString(string TextValue)
        {
            SetupAES();
            return ByteArrToString(Encrypt(TextValue));
        }

        /// Encrypt some text and return an encrypted byte array.
        public byte[] Encrypt(string TextValue)
        {
            //Translates our text value into a byte array.

            Byte[] bytes = UTFEncoder.GetBytes(TextValue);

            //Used to stream the data in and out of the CryptoStream.
            MemoryStream memoryStream = new MemoryStream();

            /*
             * We will have to write the unencrypted bytes to the stream,
             * then read the encrypted result back from the stream.
             */
            #region Write the decrypted value to the encryption stream
            CryptoStream cs = new CryptoStream(memoryStream, EncryptorTransform, CryptoStreamMode.Write);
            cs.Write(bytes, 0, bytes.Length);
           
            cs.FlushFinalBlock();
            #endregion

            #region Read encrypted value back out of the stream
            memoryStream.Position = 0;
            byte[] encrypted = new byte[memoryStream.Length];
            memoryStream.Read(encrypted, 0, encrypted.Length);
            #endregion

            //Clean up.
            cs.Close();
            memoryStream.Close();

            return encrypted;
        }

        /// The other side: Decryption methods
        public string DecryptaString(string EncryptedString)
        {
            SetupAES();
            return Decrypt(StrToByteArray(EncryptedString));
        }

        /// Decryption when working with byte arrays.    
        public string Decrypt(byte[] EncryptedValue)
        {
            #region Write the encrypted value to the decryption stream
            MemoryStream encryptedStream = new MemoryStream();
            CryptoStream decryptStream = new CryptoStream(encryptedStream, DecryptorTransform, CryptoStreamMode.Write);
            decryptStream.Write(EncryptedValue, 0, EncryptedValue.Length);
            decryptStream.FlushFinalBlock();
            #endregion

            #region Read the decrypted value from the stream.
            encryptedStream.Position = 0;
            Byte[] decryptedBytes = new Byte[encryptedStream.Length];
            encryptedStream.Read(decryptedBytes, 0, decryptedBytes.Length);
            encryptedStream.Close();
            #endregion
            return UTFEncoder.GetString(decryptedBytes);
        }

        /// Convert a string to a byte array.  NOTE: Normally we'd create a Byte Array from a string using an ASCII encoding (like so).
        //      System.Text.ASCIIEncoding encoding = new System.Text.ASCIIEncoding();
        //      return encoding.GetBytes(str);
        // However, this results in character values that cannot be passed in a URL.  So, instead, I just
        // lay out all of the byte values in a long string of numbers (three per - must pad numbers less than 100).
        public byte[] StrToByteArray(string str)
        {
            if (str.Length == 0)
                throw new Exception("Invalid string value in StrToByteArray");

            byte val;
            byte[] byteArr = new byte[str.Length / 3];
            int i = 0;
            int j = 0;
            do
            {
                val = byte.Parse(str.Substring(i, 3));
                byteArr[j++] = val;
                i += 3;
            }
            while (i < str.Length);
            return byteArr;
        }
        // Same comment as above.  Normally the conversion would use an ASCII encoding in the other direction:
        //      System.Text.ASCIIEncoding enc = new System.Text.ASCIIEncoding();
        //      return enc.GetString(byteArr);    
        public string ByteArrToString(byte[] byteArr)
        {
            byte val;
            string tempStr = "";
            for (int i = 0; i <= byteArr.GetUpperBound(0); i++)
            {
                val = byteArr[i];
                if (val < (byte)10)
                    tempStr += "00" + val.ToString();
                else if (val < (byte)100)
                    tempStr += "0" + val.ToString();
                else
                    tempStr += val.ToString();
            }
            return tempStr;
        }

        public bool IsDateValid(string dateString)
        {

        
            string[] formats = {"M/d/yyyy h:mm:ss tt", "M/d/yyyy h:mm tt",
                         "MM/dd/yyyy hh:mm:ss", "M/d/yyyy h:mm:ss",
                         "M/d/yyyy hh:mm tt", "M/d/yyyy hh tt",
                         "M/d/yyyy h:mm", "M/d/yyyy h:mm",
                         "MM/dd/yyyy hh:mm", "M/dd/yyyy hh:mm"};

            DateTime dateValue;

            // Only US format.  This can be changed to include european formats too

            if (DateTime.TryParseExact(dateString, formats,
                                    new CultureInfo("en-US"),
                                    DateTimeStyles.None,
                                    out dateValue))
            {
                // we are ignoring exact time, time zones etc.
                if (DateTime.Now.Date <= dateValue.Date)
                    return true;
            }
            return false;
        }
        static string GetFileNameFromUrl(string url)
        {
            Uri SomeBaseUri = new Uri("c:\\temp");
            Uri uri;
            if (!Uri.TryCreate(url, UriKind.Absolute, out uri))
                uri = new Uri(SomeBaseUri, url);

            return Path.GetFileName(uri.LocalPath);
        }

        private FEfinalContext db = new FEfinalContext();

        // GET: FileEncs
        public ActionResult Index()
        {
            return View(db.FileEncs.ToList());
        }

        // GET: FileEncs/Details/5
        public ActionResult Details(int? id)
        {
            if (id == null)
            {
                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
            }
            FileEnc fileEnc = db.FileEncs.Find(id);
            if (fileEnc == null)
            {
                return HttpNotFound();
            }
            fileEnc.Enc_String = DecryptaString(fileEnc.Enc_String);
            var strarray = fileEnc.Enc_String.Split(new string[] { "||" }, StringSplitOptions.None);

            if (IsDateValid (strarray[2]))
            {
                try
                {
                    string localpath = "C:\\temp\\" + GetFileNameFromUrl(strarray[0]);
                    // Need to figure out the download file name.  It needs to be unique.
                    using (WebClient wc = new WebClient())
                    { 
                        wc.Headers.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.33 Safari/537.36 Edge / 12.246");
                        wc.DownloadFile(new System.Uri(strarray[0]),
                        localpath);
                    }
                } catch
                {
                    // give error message here.
                }
            }

            return View(fileEnc);
        }


        // GET: FileEncs/Create
        public ActionResult Create()
        {
            return View();
        }

        // POST: FileEncs/Create
        // To protect from overposting attacks, please enable the specific properties you want to bind to, for 
        // more details see https://go.microsoft.com/fwlink/?LinkId=317598.
        [HttpPost]
        [ValidateAntiForgeryToken]
        public ActionResult Create([Bind(Include = "ID,FileLocation,ExpiryDate,FileType,Enc_String")] FileEnc fileEnc)
        {
            if (ModelState.IsValid)
            {
                fileEnc.ExpiryDate = fileEnc.ExpiryDate.Date;
                var compString = fileEnc.FileLocation + "||" + fileEnc.FileType + "||" + fileEnc.ExpiryDate.ToString();
                fileEnc.Enc_String = EncryptaString(compString);
                db.FileEncs.Add(fileEnc);
                db.SaveChanges();
                return RedirectToAction("Index");
            }

            return View(fileEnc);
        }

        // GET: FileEncs/Edit/5
        public ActionResult Edit(int? id)
        {
            if (id == null)
            {
                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
            }
            FileEnc fileEnc = db.FileEncs.Find(id);
            if (fileEnc == null)
            {
                return HttpNotFound();
            }
            return View(fileEnc);
        }

        // POST: FileEncs/Edit/5
        // To protect from overposting attacks, please enable the specific properties you want to bind to, for 
        // more details see https://go.microsoft.com/fwlink/?LinkId=317598.
        [HttpPost]
        [ValidateAntiForgeryToken]
        public ActionResult Edit([Bind(Include = "ID,FileLocation,ExpiryDate,FileType,Enc_String")] FileEnc fileEnc)
        {
            if (ModelState.IsValid)
            {
                db.Entry(fileEnc).State = EntityState.Modified;
                db.SaveChanges();
                return RedirectToAction("Index");
            }
            return View(fileEnc);
        }

        // GET: FileEncs/Delete/5
        public ActionResult Delete(int? id)
        {
            if (id == null)
            {
                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
            }
            FileEnc fileEnc = db.FileEncs.Find(id);
            if (fileEnc == null)
            {
                return HttpNotFound();
            }
            return View(fileEnc);
        }

        // POST: FileEncs/Delete/5
        [HttpPost, ActionName("Delete")]
        [ValidateAntiForgeryToken]
        public ActionResult DeleteConfirmed(int id)
        {
            FileEnc fileEnc = db.FileEncs.Find(id);
            db.FileEncs.Remove(fileEnc);
            db.SaveChanges();
            return RedirectToAction("Index");
        }

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                db.Dispose();
            }
            base.Dispose(disposing);
        }
    }
}


